Can you just *show* me?
~~~~~~~~~~~~~~~~~~~~~~~

Sure! While we won't take the time here to explain all these in detail, people
always want to know -- and this should give you a feeling for what you're
getting into if you have HDL experience already.

We'll write 5 circuits: we'll show the definition up-front, play with it in
various ways, and finally give some finer points about the implementation --
highlighting Clash's features.

Toggled Counter
^^^^^^^^^^^^^^^

.. todo:: FIXME

Multiply-And-Accumulate
^^^^^^^^^^^^^^^^^^^^^^^

Our next example is a basic **multiply-and-accumulate (MAC)** circuit, that
multiplies and adds its inputs over a series of clock cycles. We separate the
MAC design into its *combinational* (pure) and *sequential* (stateful)
components.

.. literalinclude:: ./examples/MAC.hs
   :language: haskell

There are some important things to note about this snippet:

- **Polymorphic definition, monomorphic circuit**: The type of the underlying
  transfer and logic functions are polymorphic. We could instantiate the
  resulting circuit to any synthesizable numeric type we desired -- in this
  case, a 9-bit signed integer.

  The overall circuit we intend to emit *must*, however, be monmorphic, with all
  of its type variables and higher order parameters made concrete.

- **Separation of concerns**: Management of state is separated from circuit
  logic, in the ``transfer`` and ``circuit`` functions, respectively. The
  ``mealy`` function ties a *state transformation* and a *pure function of that
  state* into a sequential, synchronous circuit that is synchronized to some
  clock.

- **Higher-order, stateful circuits**: The ``mealy`` function is a completely
  parametric, higher order *sequential circuit transformer* -- a classic "Mealy
  Machine" FSM -- that creates stateful logic out of pure, functional parts.
  There are also ``moore`` and ``medvedev`` machines for various other circuit
  patterns, and all of these are fully reusable.

- **Type safe clocking**: Clash requires that ``Signal`` types be annotated with
  the appropriate clock domains they correspond to. Two signals can't cross
  without an explicit synchronizer to ensure type safety. Circuits can also be
  fully polymorphic over the clock domain, as well.

- **Clocking and reset control**: The MAC example shows how synthesizable
  hardware must tie the circuit *clock line* and *reset line* -- effectively,
  the *clock domain* of an incoming signal -- into the resulting HDL. These
  lines are controlled by the ``Clock`` and ``Reset`` types, parameterized over
  the clock domain. In this case, ``withClockReset`` establishes that the
  incoming ``Clock`` and ``Reset`` lines are used for the mealy machine. (You
  could *alternatively* tie the clock lines onto an onboard PLL, or establish a
  mix of multiple clocks from oscillators and PLLs.

- **Top entities and code generation**: Clash allows you to control the input
  and output ports of circuits relatively faithfully, making integration
  simpler. This is controlled by using a *TopEntity annotation* on the desired
  top-level function, specified with the ``ANN`` pragma.

The above code can also be synthesized immediately: to compile to Verilog, just
run ``clash`` with ``--verilog``:

.. code-block:: none

    $ clash --verilog MAC.hs

The resulting circuit is located in the ``./verilog/MAC/mac/mac.v`` file,
relative to where you ran the compiler. The ``mac.v`` file contains a ``mac``
Verilog module, which can be instantiated with a clock signal, a reset signal,
two 9-bit signed input ports named ``input1`` and ``input2``, and a resulting
9-bit signed output port named ``output``. The clock and reset aren't tied to
anything, so they can come from anywhere else in your design (like a button pin,
or a PLL). Here's what the entity looks like:

.. code-block:: verilog

    /* AUTOMATICALLY GENERATED VERILOG-2001 SOURCE CODE.
    ** GENERATED BY CLASH 1.0.0. DO NOT MODIFY.
    */
    module mac
        ( // Inputs
          input clk // clock
        , input rst // asynchronous reset: active high
        , input signed [8:0] in1
        , input signed [8:0] in2

          // Outputs
        , output wire signed [8:0] out
        );

Feel free to hook this result up to any synthesis tool you desire. This is your
first Clash circuit!

Finite Impulse Response
^^^^^^^^^^^^^^^^^^^^^^^

Next, we have a **Finite Impulse Response (FIR) filter**, a basic building block
of signal processing. It computes the dot product of a vector of coefficient
signals, against a *sliding window* over the input signal:

.. literalinclude:: ./examples/FIR.hs
   :language: haskell

This code is not an error: load it into ``clashi`` and ask for the type of
``fir``!

.. code-block:: none

    $ clashi FIR.hs
    *Main> :t fir

For simplicity, the cleaned up type is as follows:

.. code-block:: haskell

      fir :: ( KnownNat n                    -- number of coefficients minus 1
             , Num a, Default a              -- numeric type with default value
             , ?rst :: Reset dom sync        -- implicit: reset line
             , ?clk :: Clock dom gated       -- implicit: clock line
             ) => Vec (n + 1) (Signal dom a) -- a vector of coefficient signals
               -> Signal dom a               -- input signal
               -> Signal dom a               -- output signal

There are also some important notes to take away from this example:

- **Parametric in the number of taps**: the FIR definition is invariant in the
  underlying number of coefficients or "tap count" chosen by the user -- *you*
  chose the number of the taps, at the call site.

- **Parametric and extensible in the underlying data type**: The FIR can be
  defined over any data type that satisfies the ``Num`` constraint and
  ``Default`` constraint -- including any synthesizable numeric type *you*
  wrote.

- **No type annotations, yet completely type safe**: Despite all of the above,
  the Clash compiler can infer the type of the ``fir`` function with no help at
  all! The size of the input coefficient vector determines the size of the
  sliding ``window`` automatically.

And remember (from the MAC example): you *can't* immediately synthesize the
above example, because it contains polymorphic type variables!

Bitonic Sorting
^^^^^^^^^^^^^^^

Another classic FPGA example is a **Bitonic sorter** -- a parallel `sorting
network <https://en.wikipedia.org/wiki/Sorting_network>`_ that uses
:math:`O(\log^2(n))` comparators, with a latency of :math:`O(\log^2(n))` as
well:

.. code-block:: haskell

    module Sort
      ( bmerge
      , bsort
      , bsorter
      ) where

    import Clash.Prelude

    cas :: Ord a => a -> a -> (a, a)
    cas x y | x > y     = (x, y)
            | otherwise = (y, x)

.. todo:: INCOMPLETE

This design is purely combinational, not sequential -- but it still shows off
some distinctive, advanced features:

- **Advanced type level arithmetic**: The Clash compiler augments the normal
  type checking capabiltiies of GHC with a more advanced solver for *type level
  integers*, including new operations, as well as *limited* automatic discharge
  of equality proofs and constraints.

  For example, in the above, Clash is able to see that the type of ``bmerge`` is
  a function that takes a HOF, from vectors of length ``n -> n``, as well as an
  input vector of **twice that size**. Types like ``2 * n`` naturally constrain
  the given type to double the size. In the event you passed a ``Vec`` with a
  type like ``Vec (n * n) a``, Clash would be able to prove they sizes are
  equivalent automatically. Similarly, a type like ``Vec (2 ^ n) a`` constrains
  a vector to a size which is a power of two.

- **Dependent, type-level generic programming**: The ``bsorter`` code above
  shows off the power of Clash and Haskell's type system to *automatically*
  derive type-safe code that is generic in the "width" of the sorting network,
  using a limited form of dependent types.

  The ``dfold`` function performs a **dependent vector fold** using a given base
  case, induction step, and input vector. The Clash compiler type checks this
  code, and the type of ``dfold`` ensures that folding always terminates over
  the input, and is "structurally inductive" over the input list. With this
  knowledge/proof of termination, the Clash compiler is free to "unroll" this
  definition for every given concrete set of type variables.

  All of this however is wrapped up in a completely generic, reusable type that
  is easy to understand:

  .. code-block:: haskell

      -- | Size-generic Bitonic Sorter. Input must be a power-of-two size.
      bsorter :: (Ord a, KnownNat k) => Vec (2^k) a -> Vec (2^k) a

  For example, if we chose the type ``k=4``, this would give a bitonic sorter
  for arbitrary 16-entry vectors. The use of ``bsorter`` in this case would be
  equivalent to writing out the following definition of ``bsort16``, manually:

  .. code-block:: haskell

     bsort16 :: Ord a => Vec 16 a -> Vec 16
     bsort16 = sort16
       where
         sort16  = bsort sort8 merge16
         merge16 = bmerge merge8

         sort8  = bsort sort4 merge8
         merge8 = bmerge merge4

         sort4  = bsort sort2 merge4
         merge4 = bmerge merge2

         sort2  = bsort id merge2
         merge2 = bmerge id

Extreme Overengineering
^^^^^^^^^^^^^^^^^^^^^^^

Finally, to show you the range of design approaches in Clash, let's revisit the
second example -- a simple MAC circuit -- and make it an extremely
over-engineered, unreadable mess by using a lot of fancy features!

.. warning:: This is a **dark, spooky piece of overdone code** and if you stare
             at it for too long, your family line will be cursed!

.. literalinclude:: ./examples/Overdrive.hs
   :language: haskell

Aside from turning 3 lines of easy-to-read-code into 200 lines of obscure
nightmare code (improving our job security) -- this example *also* shows off
some important features, most of them unique to Clash:

- **(Almost) No feature loss**: Unlike DSLs or complex staging approaches, Clash
  *is* Haskell, and is a pure compiler from (GHC) Haskell to HDL. It supports
  almost every Haskell feature and tool -- like ``GeneralizedNewtypeDeriving``
  and ``TemplateHaskell``.

- **Clash and Haskell interoperate**: the above example cleanly uses ``lens``
  and ``mtl`` from the installed package set to define the circuit. You can just
  use Haskell packages!

- **Not a DSL**: Clash isn't a DSL -- it really takes Haskell input, and
  compiles it to HDL, using a static analysis approach to compilation. There is
  no "object" and "meta" language distinction -- there is only *one* language,
  with the same set of abstractions you're used to. In the above example,
  packages like ``lens`` or ``mtl`` aren't just managed with the same tools --
  *they are analyzed and optimized away during the compile stage, just like
  always!*

- **Existing code works**: much existing Haskell code -- like the core
  foundations of ``lens`` and ``mtl`` -- transparently work with Clash with
  little effort. While the programming model is different, the high level of
  abstraction in most Haskell code means that *most transformations are
  independent of the underlying semantic data representation or 'shape' of
  code*. So most existing, foundational abstractions -- ``Monoid``,
  ``Applicative``, ``Bounded`` types and ``Enum`` types, or classic tools like
  ``Maybe`` and ``Either`` -- work effortlessly in a completely new domain.

- **Synthesis and simulation, in one language**: Much like Verilog or VHDL,
  Clash can be simulated in software, *and* synthesized to hardware -- this
  means you can write test benches and "surrounding tools" for your circuits
  trivially in Haskell. The Clash compiler won't attempt to synthesize parts of
  the code your circuits don't use -- so a single file can contain both hardware
  *and* software.

